#include "movementpath.h"

MovementPath::MovementPath()
{
    __build();
}

MovementPath::MovementPath(Point3d<float> origin)
{
    __build();
    _origin=origin;
}

void MovementPath::__build(){
    resetPosition();
    _progression_max=100;
    _target=NULL;
    _activated=false;
    _type=once;
}

void MovementPath::drawPath(bool partial){

}

void MovementPath::displayPoints(){

}


float MovementPath::newPosition(float origin, float target, int progression, int progression_max){
    float value=0.0f;
    float d;
    d=target-origin;
    value = d*((float)progression/(float)progression_max)+origin;
    return value;
}

Point3d<float> MovementPath::nextPosition(){
    _position.x(newPosition(_origin.x(),_target_position.x(), _progression, _progression_max ));
    _position.y(newPosition(_origin.y(),_target_position.y(), _progression, _progression_max ));
    _position.z(newPosition(_origin.z(),_target_position.z(), _progression, _progression_max ));

    if(_target!=NULL){
        _target->get_transform().set_position(_position);
    }

    updateProgression();
    return _position;
}

void MovementPath::updateProgression(){
    _progression++;
    if(_progression==_progression_max) progressionOver();
}

void MovementPath::progressionOver(){
    switch(_type){
    case loop:
        resetPosition();
        break;
    case once:
        _activated=false;
        _target->set_moving(false);
        break;
    case disappear:
        _activated=false;
        _target->set_moving(false);
        _target->set_visible(false);
        break;
    case erase:
        _activated=false;
        _target->set_moving(false);
        break;
    }
}

void MovementPath::resetPosition(){
    _progression=0;
    _position=_origin;
}




